/**
 * @constructor
 */
function FitchCalculator(){ 
    this.GAP_EXT = -1;       // Gap extension penalty
    this.GAP_OPEN = -4;       // Gap open penalty
    this.CHARS = {"T": 1, "A": 2, "G": 4, "C": 8, ".": 16};
    this.CHARS_INDEX = {"T": 0, "A": 1, "G": 2, "C": 3, ".": 4};
    this.RCHARS = ["T", "A", "G", "C", "."];
    this.SCORE_MATRIX = {   // matrix used for scoring
        "A":{"A": 1, "C": -1, "G": -1, "T": -1, ".": -1},
        "C":{"A": -1, "C": 1, "G": -1, "T": -1, ".": -1},
        "G":{"A": -1, "C": -1, "G": 1, "T": -1, ".": -1},
        "T":{"A": -1, "C": -1, "G": -1, "T": 1, ".": -1},
        ".":{"A": -1, "C": -1, "G": -1, "T": -1, ".": 0}
    };
    this.GAP_MATRIX = {   // matrix used for determining if gap [parent][child]
        "A":{"A": 0, "C": 0, "G": 0, "T": 0, ".": 1},
        "C":{"A": 0, "C": 0, "G": 0, "T": 0, ".": 1},
        "G":{"A": 0, "C": 0, "G": 0, "T": 0, ".": 1},
        "T":{"A": 0, "C": 0, "G": 0, "T": 0, ".": 1},
        ".":{"A": 1, "C": 1, "G": 1, "T": 1, ".": 0}
    };
}

FitchCalculator.diffSeqs = function(s1, s2){
    var difference = 0;
    var extra = 0;
    var missing = 0;
    var score;
    for (var i = 0; i < fold.length; i++){
        score = this.diffMatrix[this.original.charAt(i)][fold.charAt(i)];
        difference += score[0];
        extra += score[1];
        missing += score[2];
    }
    return {"difference": difference, "extra": extra, "missing": missing};
}

FitchCalculator.treeops = {};

/**
 * Given tree and a comparator function, return the first node
 * where the comparator function returns an expression that evaluates
 * true.
 */
FitchCalculator.treeops.findNode = function find(tree, comp){
    var walk = function rec(tree, comp, ctx){
        if (tree instanceof Object && tree[0] != undefined){
            // node
            if (comp.bind(ctx)(tree)){
                return tree;
            }
            var res = rec(tree[0], comp, ctx);
            if (res != null){
                return res;
            }
            return rec(tree[1], comp, ctx);
        }else{
            // leaf
            return null;
        }
    }
    return walk(tree, comp, this);
}

/**
 * Given tree and a number n, return the n-th node in the tree by
 * pre-order traversal.
 */
FitchCalculator.treeops.findNthNode = function find(tree, n){
    var walk = function rec(tree, index){
        if (tree instanceof Object && tree[0] != undefined){
            // node
            if (index.count == n){
                return tree;
            }
            index.count += 1;
            var res = rec(tree[0], index);
            if (res != null){
                return res;
            }
            return rec(tree[1], index);
        }else{
            // leaf
            return null;
        }
    }
    var ind = {count: 0};
    return walk(tree, ind);
}

/**
 * Given a tree and a node in the tree, return the pre-order index of
 * the given node.
 */
FitchCalculator.treeops.getNodeIndex = function find(tree, node){
    var walk = function rec(tree, index){
        if (tree instanceof Object && tree[0] != undefined){
            // node
            if (tree == node){
                return index.count;
            }
            index.count += 1;
            var res = rec(tree[0], index);
            if (res != null){
                return res;
            }
            return rec(tree[1], index);
        }else{
            // leaf
            return -1;
        }
    }
    var ind = {count: 0};
    return walk(tree, ind);    
}

FitchCalculator.buildTree = function btree(structure, data){
    if (structure instanceof Array){
        return [btree(structure[0], data), btree(structure[1], data)];
    }else{
        return data.shift();
    }
}

FitchCalculator.seqLength = function(seqs){
    if (seqs instanceof Array){
        return FitchCalculator.seqLength(seqs[0]);
    }else{
        return seqs.length;
    }
}

FitchCalculator.prototype.getFinalTree = function build(seqs, override){
    var onesCount = function(x){
        x -= ((x >> 1) & 0x55555555);
        x = (((x >> 2) & 0x33333333) + (x & 0x33333333));
        x = (((x >> 4) + x) & 0x0f0f0f0f);
        x += (x >> 8);
        x += (x >> 16);
        return(x & 0x0000003f);
    }
    var trailingZeroCount = function(x){
        return(onesCount((x & -x) - 1));
    }
    /*
        The trees generated by diffLocations are by separated by locations. This function
        merges multiple copies of the trees generated by diffLocations and puts them into
        one easy to interpret tree for the whole phylogeny.
    */
    var addToTree = function rec(single, location, out, override,myancestor){
	// results are stored in out. init "out" if at the first call. 
	// IDXCONVERT is just a patch to convert from CHARS_INDEX to binary code
	var IDXCONVERT = [1,2,4,8,16];
        if (single instanceof Array){
            if (out.seq == undefined){
                out.seq = new Array;
                out.ancestor = new Array;
                out[0] = {};
                out[1] = {};
            }
	    if (override.value == undefined || override.value[location] == undefined){
		if ((single[2] & IDXCONVERT[myancestor]) == 0){
		    out.ancestor[location] = Math.min(trailingZeroCount(single[2]), 4);
		}else{
		    out.ancestor[location] = myancestor;
		}
	    }else{                                                                                                                   
                overridecode = 1 << override.value[location];                                                                   
		out.ancestor[location] = Math.min(trailingZeroCount(overridecode), 4);
            }
            var left  = rec(single[0], location, out[0], override[0],out.ancestor[location]);
            var right = rec(single[1], location, out[1], override[1],out.ancestor[location]);
            //S(v) = {    S(u) n S(w), if S(u) n S(w) != 0
            //            S(u) u S(w), if S(u) n S(w) = 0
	    /*
            if (override.value == undefined || override.value[location] == undefined){
                if ((left & right) == 0){
                    out.seq[location] = left | right;
                }else{
                    out.seq[location] = left & right;
                }
            }else{
                out.seq[location] = 1 << override.value[location];
            }
            out.ancestor[location] = Math.min(trailingZeroCount(out.seq[location]), 4);
            return out.seq[location];
	    */
	    return single[2];
        }else{
            if (out.seq == undefined){
                out.seq = new Array;
                out.ancestor = new Array;
            }
            out.seq[location] = single;
            out.ancestor[location] = Math.min(trailingZeroCount(single), 4);
            return single;
        }
    }
    
     var writeStringAncestors = function rec(ctree, matrix){
        if (ctree instanceof Array || (ctree instanceof Object && ctree[0] != undefined)){
            rec(ctree[0], matrix);
            rec(ctree[1], matrix);
            ctree.stringancestor = "";
            for (var i = 0; i < ctree.ancestor.length; i++){
                ctree.stringancestor += matrix[ctree.ancestor[i]];
            }
        }
    }
    
    console.log(onesCount(0xF));
    console.log(trailingZeroCount(0xF1));

    var ancestor = new Array;
    var parsimony = new Array;
    var treearr = new Array;
    var length = FitchCalculator.seqLength(seqs);
    for (var i = 0; i < length; i++){
        var result = this.diffLocation2(seqs, i);
        ancestor[i] = result.ancestor;
        parsimony[i] = result.parsimony;
	// treearr is the tree wil visible nucleotides and column i, and field[2] stores ancestors
        treearr[i] = result.tree;
    }
    var finaltree = new Array;
    // treearr represents the grid configuration
    for (var i = 0; i < treearr.length; i++){
        addToTree(treearr[i], i, finaltree, override,0);
    }

    var oneAncestor = "";
    for (var i = 0; i < finaltree.ancestor.length; i++){
        oneAncestor += this.RCHARS[finaltree.ancestor[i]];
    }
    writeStringAncestors(finaltree, this.RCHARS);
    //console.log(DumpObjectIndented(finaltree), '\t');
    var info = {"match": 0, "mismatch": 0, "gap_ext": 0, "gap_open": 0};
    var score = this.scoreTreeAlignment.bind(this)(finaltree, info);
    var ret = {};
    ret.ancestor = oneAncestor;
    ret.score = score;
    ret.tree = finaltree;
    ret.info = info;
    return ret;
}

FitchCalculator.prototype.scoreTreeAlignment = function rec(tree, info){
    if (tree instanceof Object && tree[0] != undefined){
        var score = 0;
        var thisscore = 0;
        score += rec.bind(this)(tree[0], info);
        score += rec.bind(this)(tree[1], info);
        thisscore += this.scoreAlignment(tree.ancestor, tree[0].ancestor, info);
        thisscore += this.scoreAlignment(tree.ancestor, tree[1].ancestor, info);
        tree.score = score + thisscore;
        return score + thisscore;
    }else{
        return 0;
    }
}

FitchCalculator.prototype.scoreAlignment = function(parent, child, info){
    var score = 0;
    var gap = false;
    var gaplength = 0;
    var start = true;
    for (var i = 0; i < parent.length; i++){
        if (this.GAP_MATRIX[this.RCHARS[parent[i]]][this.RCHARS[child[i]]] == 1){
            if (!start){    // ignore gaps at the start
                if (gap){
                    score += this.GAP_EXT;
                    info['gap_ext'] += 1;
                    gaplength++;
                }else{
                    score += this.GAP_OPEN;
                    gap = true;
                    info['gap_open'] += 1;
                    gaplength = 1;
                }
            }
        }else{
	    if (this.SCORE_MATRIX[this.RCHARS[parent[i]]][this.RCHARS[child[i]]]!=0) { // filter empty columns
		gap = false;
		start = false;
		score += this.SCORE_MATRIX[this.RCHARS[parent[i]]][this.RCHARS[child[i]]];
		if (this.SCORE_MATRIX[this.RCHARS[parent[i]]][this.RCHARS[child[i]]] > 0){
		    info['match'] += 1;
		}else{
		    info['mismatch'] += 1;
		}
	    }
        }
    }
    // compensate for gaps at the end
    if (gap){
        score -= (gaplength - 1) * this.GAP_EXT + this.GAP_OPEN;
        info['gap_ext'] -= gaplength - 1;
        info['gap_open'] -= 1;
    }
    return score;
}

FitchCalculator.prototype.diffLocation2 = function(seqs, location){
    var parsimonyScore = [ 0 ];
    var calculateAncestor = function rec(tree, z){
	if (tree instanceof Array){
	    var left = rec(tree[0], z);
	    var right = rec(tree[1], z);      
	    if ((left & right) == 0){
		z[0]++;
		tree.seq = left | right;
	    }else{
		tree.seq = left & right;
	    }
	    tree[2]=tree.seq;
	    return tree.seq;
	}else{
            return tree;
	}
    }
    // extracted is the sequence of nuc in the grid per columns. recursive structure.
    var extracted = this.extractLocation(seqs, location);
    // possible ancestors at root in binary format
    var ancestor = calculateAncestor(extracted, parsimonyScore);
    //alert(extracted.join('\n'));
    var ret = {};
    ret.ancestor = ancestor;
    ret.parsimony = parsimonyScore[0];
    ret.tree = extracted;
    return ret;
}

FitchCalculator.prototype.diffLocation = function(seqs, location){
    var parsimonyScore = [ 0 ];
    var calculateAncestor = function rec(tree, z){
        if (tree instanceof Array){
            var left = rec(tree[0], z);
            var right = rec(tree[1], z);
            //S(v) = {    S(u) n S(w), if S(u) n S(w) != 0
            //            S(u) u S(w), if S(u) n S(w) = 0
            if ((left & right) == 0){
                z[0]++;
                tree.seq = left | right;
                return tree.seq;
            }else{
                tree.seq = left & right;
                return tree.seq;
            }
        }else{
            return tree;
        }
    }
    // extracted is the sequence of nuc in the grid per columns. recursive structure.
    var extracted = this.extractLocation(seqs, location);
    // possible ancestors at root in binary format
    var ancestor = calculateAncestor(extracted, parsimonyScore);
    var ret = {};
    ret.ancestor = ancestor;
    ret.parsimony = parsimonyScore[0];
    ret.tree = extracted;
    return ret;
}

FitchCalculator.prototype.extractLocation = function (seqs, location){
    if (seqs instanceof Array){
        return [this.extractLocation(seqs[0], location),
            this.extractLocation(seqs[1], location)]
    }else{
        return this.CHARS[seqs.charAt(location)];
    }
}

var fitch = new FitchCalculator();

/*
var sampleData = [ [ [ 'ACG', 'AGG' ], 'AGC' ], 'AGT' ];
var sample2 = [ [ [ '.ACGAAAGATAAAAAGC..', 'AGCGCATAACCATGCAC..' ], '..CAGTTACTTGTAAGC..' ], '..GTAAAAATAGTATTCAG' ];
var loc1 = fitch.extractLocation(sample2, 2);

document.write('<pre>' + JSON.stringify(sample2, null, '\t') + '</pre>');
document.write('<pre>' + JSON.stringify(loc1, null, '\t') + '</pre>');
document.write('<pre>' + JSON.stringify(fitch.diffLocation(sample2, 2), null, '\t') + '</pre>');
document.write('<pre>' + JSON.stringify(fitch.findAncestor(sample2, 2), null, '\t') + '</pre>');
document.write('<pre>' + JSON.stringify(fitch.getFinalTree(sample2), null, '\t') + '</pre>');


var flatten = function flat(tree, out){
    if (tree instanceof Array){
        flat(tree[0], out);
        flat(tree[1], out);
    }else{
        out.push(tree);
    }
}
var flat = new Array;
flatten(sample2, flat);
document.write('<pre>' + JSON.stringify(flat, null, '\t') + '</pre>');
document.write('<pre>' + JSON.stringify(FitchCalculator.buildTree(loc1, flat), null, '\t') + '</pre>');
*/


function DumpObjectIndented(obj, indent)
{
  var result = "";
  if (indent == null) indent = "";

  for (var property in obj)
  {
    var value = obj[property];
    if (typeof value == 'string')
      value = "'" + value + "'";
    else if (typeof value == 'object')
    {
      if (value instanceof Array)
      {
        // Just let JS convert the Array to a string!
        value = "[ " + value + " ]";
      }
      else
      {
        // Recursive dump
        // (replace "  " by "\t" or something else if you prefer)
        var od = DumpObjectIndented(value, indent + "  ");
        // If you like { on the same line as the key
        //value = "{\n" + od + "\n" + indent + "}";
        // If you prefer { and } to be aligned
        value = "\n" + indent + "{\n" + od + "\n" + indent + "}";
      }
    }
    result += indent + "'" + property + "' : " + value + ",\n";
  }
  return result.replace(/,\n$/, "");
}
